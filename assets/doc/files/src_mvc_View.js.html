<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/mvc/View.js - lavaca</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="lavaca"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/lavaca.env.Device.html">lavaca.env.Device</a></li>
            
                <li><a href="../classes/lavaca.events.EventDispatcher.html">lavaca.events.EventDispatcher</a></li>
            
                <li><a href="../classes/lavaca.fx.Animation.html">lavaca.fx.Animation</a></li>
            
                <li><a href="../classes/lavaca.fx.Spring.html">lavaca.fx.Spring</a></li>
            
                <li><a href="../classes/lavaca.fx.Transform.html">lavaca.fx.Transform</a></li>
            
                <li><a href="../classes/lavaca.fx.Transition.html">lavaca.fx.Transition</a></li>
            
                <li><a href="../classes/lavaca.mvc.Application.html">lavaca.mvc.Application</a></li>
            
                <li><a href="../classes/lavaca.mvc.AttributeEvent.html">lavaca.mvc.AttributeEvent</a></li>
            
                <li><a href="../classes/lavaca.mvc.Collection.html">lavaca.mvc.Collection</a></li>
            
                <li><a href="../classes/lavaca.mvc.Controller.html">lavaca.mvc.Controller</a></li>
            
                <li><a href="../classes/lavaca.mvc.ItemEvent.html">lavaca.mvc.ItemEvent</a></li>
            
                <li><a href="../classes/lavaca.mvc.Model.html">lavaca.mvc.Model</a></li>
            
                <li><a href="../classes/lavaca.mvc.Route.html">lavaca.mvc.Route</a></li>
            
                <li><a href="../classes/lavaca.mvc.Router.html">lavaca.mvc.Router</a></li>
            
                <li><a href="../classes/lavaca.mvc.View.html">lavaca.mvc.View</a></li>
            
                <li><a href="../classes/lavaca.mvc.ViewManager.html">lavaca.mvc.ViewManager</a></li>
            
                <li><a href="../classes/lavaca.net.Connectivity.html">lavaca.net.Connectivity</a></li>
            
                <li><a href="../classes/lavaca.net.History.html">lavaca.net.History</a></li>
            
                <li><a href="../classes/lavaca.storage.LocalStore.html">lavaca.storage.LocalStore</a></li>
            
                <li><a href="../classes/lavaca.storage.Store.html">lavaca.storage.Store</a></li>
            
                <li><a href="../classes/lavaca.ui.DustTemplate.html">lavaca.ui.DustTemplate</a></li>
            
                <li><a href="../classes/lavaca.ui.Form.html">lavaca.ui.Form</a></li>
            
                <li><a href="../classes/lavaca.ui.LoadingIndicator.html">lavaca.ui.LoadingIndicator</a></li>
            
                <li><a href="../classes/lavaca.ui.Template.html">lavaca.ui.Template</a></li>
            
                <li><a href="../classes/lavaca.ui.Widget.html">lavaca.ui.Widget</a></li>
            
                <li><a href="../classes/lavaca.util.ArrayUtils.html">lavaca.util.ArrayUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Cache.html">lavaca.util.Cache</a></li>
            
                <li><a href="../classes/lavaca.util.Config.html">lavaca.util.Config</a></li>
            
                <li><a href="../classes/lavaca.util.DateUtils.html">lavaca.util.DateUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Disposable.html">lavaca.util.Disposable</a></li>
            
                <li><a href="../classes/lavaca.util.extend.html">lavaca.util.extend</a></li>
            
                <li><a href="../classes/lavaca.util.Map.html">lavaca.util.Map</a></li>
            
                <li><a href="../classes/lavaca.util.Promise.html">lavaca.util.Promise</a></li>
            
                <li><a href="../classes/lavaca.util.resolve.html">lavaca.util.resolve</a></li>
            
                <li><a href="../classes/lavaca.util.StringUtils.html">lavaca.util.StringUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Translation.html">lavaca.util.Translation</a></li>
            
                <li><a href="../classes/lavaca.util.uuid.html">lavaca.util.uuid</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/mvc/View.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
define(function(require) {

  var $ = require(&#x27;$&#x27;),
    EventDispatcher = require(&#x27;lavaca/events/EventDispatcher&#x27;),
    Model = require(&#x27;lavaca/mvc/Model&#x27;),
    Template = require(&#x27;lavaca/ui/Template&#x27;),
    Cache = require(&#x27;lavaca/util/Cache&#x27;),
    Promise = require(&#x27;lavaca/util/Promise&#x27;),
    ArrayUtils = require(&#x27;lavaca/util/ArrayUtils&#x27;),
    uuid = require(&#x27;lavaca/util/uuid&#x27;);

  var _UNDEFINED;

  /**
   * Base View Class
   * @class lavaca.mvc.View
   * @extends lavaca.events.EventDispatcher
   *
   * @constructor
   * @param {Object | String} el the selector or Object for the element to attach to the view
   * @param {Object} [model] the model for the view
   * @param {Object} [parentView] the parent view for the view
   *
   * @constructor
   * @param {Object | String} el the selector or Object for the element to attach to the view
   * @param {Object} [model] the model for the view
   * @param {Object} [layer] The layer on which the view sits (only applicable to views used as a PageView)
   *
   *
   */
  var View = EventDispatcher.extend(function(el, model, parentView) {
    EventDispatcher.call(this);

    /**
     * The model used by the view
     * @property model
     * @default null
     * @optional
     * @type lavaca.mvc.Model
     *
     */
    this.model = model || null;

    /**
     * The element containing the view
     * @property {jQuery} shell
     * @default null
     */
    this.shell = null;


    /**
     * An id is applied to a data property on the views container
     * @property id
     * @default generated from className and unique identifier
     * @type String
     *
     */
    this.id = (this.className + &#x27;-&#x27; + uuid()).replace(&#x27; &#x27;, &#x27;-&#x27;);

    if (typeof parentView !== &#x27;number&#x27;) {
      /**
       * If the view is created in the context of a childView, the parent view is assigned to this view
       * @property parentView
       * @default null
       * @type Object
       *
       */
      this.parentView = parentView || null;

    } else {
      this.layer = parentView;
    }

    /**
     * The element that is either assigned to the view if in the context of a childView, or is created for the View
     * if it is a PageView
     * @property el
     * @default null
     * @type Object | String
     *
     */
    this.el = typeof el === &#x27;string&#x27; ? $(el) : (el || null);


    /**
     * A dictionary of selectors and event types in the form
     * {eventType: {delegate: &#x27;xyz&#x27;, callback: func}}@property el
     * @property eventMap
     * @default {}
     * @type Object
     */
    this.eventMap = {};
    /**
     * A dictionary of selectors, View types and models in the form
     *   {selector: {TView: TView, model: model}}}
     * @property {Object} childViewMap
     * @default {}
     * @type Object
     *
     */
    this.childViewMap = {};
    /**
     * Interactive elements used by the view
     * @property childViews
     * @default lavaca.util.cache
     * @type lavaca.util.Cache
     */
    this.childViews = new Cache();
    /**
     * A dictionary of selectors and widget types in the form
     *   {selector: widgetType}
     * @property {Object} widgetMap
     * @default {}
     * @type Object
     */
    this.widgetMap = {};
    /**
     * Interactive elements used by the view
     * @property widgets
     * @default lavaca.util.Cache
     * @type lavaca.util.Cache
     */
    this.widgets = new Cache();
    /**
     *  A map of all the events to be applied to child Views in the form of
     *  {type: {TView: TView, callback : callback}}
     * @property childViewEventMap
     * @default Object
     * @type Object
     */
    this.childViewEventMap = {};

    this
      .on(&#x27;rendersuccess&#x27;, this.onRenderSuccess)
      .on(&#x27;rendererror&#x27;, this.onRenderError);
  }, {
    /**
     * Will render any childViews automatically when set to true
     * @property autoRender
     * @default false
     *
     * @type Boolean
     */
    autoRender: false,
    /**
     * The name of the template associated with the view
     * @property {String} template
     * @default null
     *
     */
    template: null,
    /**
     * A class name added to the view container
     * @property String className
     * @default null
     *
     */
    className: null,


    /**
     * The index of the layer on which the view sits
     * @property {Number} layer
     * @default 0
     */
    layer: 0,

    /**
     * Type of view, ex PageView, View
     * @property String viewType
     * @default null
     */
    viewType: null,

    bindRenderEvents: function(renderPromise) {
      var promise = new Promise(this);
      /*
       * Fires when html from template has rendered
       * @event rendersuccess
       */
      promise
        .success(function(html) {
          this.trigger(&#x27;rendersuccess&#x27;, {html: html});
          renderPromise.resolve();
        })
      /**
       * Fired when there was an error during rendering process
       * @event rendererror
       */
        .error(function(err) {
          this.trigger(&#x27;rendererror&#x27;, {err: err});
          renderPromise.reject();
        });

      return promise;
    },

    renderTemplate: function(template, promise, model) {
      return template
        .render(model)
        .success(promise.resolver())
        .error(promise.rejector());
    },

    getRenderModel: function() {
      var model = this.model;
      return model instanceof Model ? model.toObject() : model;
    },
    /**
     * Renders the view using its template and model
     * @method render
     *
     * @return {lavaca.util.Promise} A promise
     */
    render: function() {
      var self = this,
          renderPromise = new Promise(this),
          promise = this.bindRenderEvents(renderPromise),
          template = Template.get(this.template),
          model = this.getRenderModel();

      this.renderTemplate(template, promise, model)
        .then(function() {
          if (self.className){
            self.el.addClass(self.className);
          }
        });

      return renderPromise;

    },
    /**
     * Renders the view using its template and model
     * @method renderPageView
     *
     * @return {lavaca.util.Promise} A promise
     */
    renderPageView: function() {
      var renderPromise = new Promise(this),
          promise = this.bindRenderEvents(renderPromise),
          template = Template.get(this.template),
          model = this.getRenderModel();

      if (this.el) {
        this.el.remove();
      }

      this.shell = this.wrapper();
      this.el = this.interior();
      this.shell.append(this.el);
      this.shell.attr(&#x27;data-layer-index&#x27;, this.layer);
      if (this.className) {
        this.shell.addClass(this.className);
      }

      this.renderTemplate(template, promise, model);

      return renderPromise;

    },

    /**
     * Re-renders the view&#x27;s template and replaces the DOM nodes that match
     * the selector argument. If no selector argument is provided, the whole view
     * will be re-rendered. If the first parameter is passed as &lt;code&gt;false&lt;/code&gt;
     * the resulting html will pe passed with the promise and nothing will be replaced.
     * Note: the number of elements that match the provided selector must be identical
     * in the current markup and in the newly rendered markup or else the returned
     * promise will be rejected.
     * Re-renders the view&#x27;s template using the view&#x27;s model
     * and redraws the entire view
     * @method redraw
     *
     * @return {lavaca.util.Promise} A promise
     */
    /**
     * Re-renders the view&#x27;s template using the specified model
     * and redraws the entire view
     * @method redraw
     * @param {Object} model  The data model to be passed to the template
     * @return {lavaca.util.Promise} A promise
     */
    /**
     * Re-renders the view&#x27;s template using the view&#x27;s model and only redraws the
     * elements that match the specified selector string.
     * Note: The numbers of items that match the selector must
     * be exactly the same in the view&#x27;s current markup and in the newly rendered
     * markup. If that is not the case, the returned promise will be rejected and
     * nothing will be redrawn.
     * @method redraw
     * @param {String} selector  Selector string that defines elements to redraw
     * @return {lavaca.util.Promise} A promise
     */
    /**
     * Re-renders the view&#x27;s template using the specified model and only redraws the
     * elements that match the specified selector string.
     * Note: The numbers of items that match the selector must
     * be exactly the same in the view&#x27;s current markup and in the newly rendered
     * markup. If that is not the case, the returned promise will be rejected and
     * nothing will be redrawn.
     * @method redraw
     * @param {String} selector  Selector string that defines elements that will be updated
     * @param {Object} model  The data model to be passed to the template
     * @return {lavaca.util.Promise} A promise
     */
    /**
     * Re-renders the view&#x27;s template using the view&#x27;s model. If shouldRedraw is true,
     * the entire view will be redrawn. If shouldRedraw is false, nothing will be redrawn,
     * but the returned promise will be resolved with the newly rendered content. This allows
     * the caller to attach a success handler to the returned promise and define their own
     * redrawing behavior.
     * @method redraw
     * @param {Boolean} shouldRedraw  Whether the view should be automatically redrawn.
     * @return {lavaca.util.Promise}  A promise
     */
    /**
     * Re-renders the view&#x27;s template using the specified model. If shouldRedraw is true,
     * the entire view will be redrawn. If shouldRedraw is false, nothing will be redrawn,
     * but the returned promise will be resolved with the newly rendered content. This allows
     * the caller to attach a success handler to the returned promise and define their own
     * redrawing behavior.
     * @method redraw
     * @param {Boolean} shouldRedraw  Whether the view should be automatically redrawn.
     * @param {Object} model  The data model to be passed to the template
     * @return {lavaca.util.Promise}  A promise
     */
    redraw: function(selector, model) {
      var self = this,
        templateRenderPromise = new Promise(this),
        redrawPromise = new Promise(this),
        template = Template.get(this.template),
        replaceAll;
      if (!template) {
        return redrawPromise.reject();
      }
      if (typeof selector === &#x27;object&#x27; || selector instanceof Model) {
        model = selector;
        replaceAll = true;
        selector = null;
      }
      else if (typeof selector === &#x27;boolean&#x27;) {
        replaceAll = selector;
        selector = null;
      } else if (!selector) {
        replaceAll = true;
      }
      model = model || this.model;
      if (model instanceof Model) {
        model = model.toObject();
      }

      // process widget, child view, and
      // child view event maps
      function processMaps() {
        self.createWidgets();
        self.createChildViews();
        self.applyChildViewEvents();
        self.trigger(&#x27;redrawsuccess&#x27;);
      }
      templateRenderPromise
        .success(function(html) {
          if (replaceAll) {
            this.disposeChildViews(this.el);
            this.disposeWidgets(this.el);
            this.el.html(html);
            processMaps();
            redrawPromise.resolve(html);
            return;
          }
          if(selector) {
            var $newEl = $(&#x27;&lt;div&gt;&#x27; + html + &#x27;&lt;/div&gt;&#x27;).find(selector),
              $oldEl = this.el.find(selector);
            if($newEl.length === $oldEl.length) {
              $oldEl.each(function(index) {
                var $el = $(this);
                self.disposeChildViews($el);
                self.disposeWidgets($el);
                $el.replaceWith($newEl.eq(index)).remove();
              });
              processMaps();
              redrawPromise.resolve(html);
            } else {
              redrawPromise.reject(&#x27;Count of items matching selector is not the same in the original html and in the newly rendered html.&#x27;);
            }
          } else {
            redrawPromise.resolve(html);
          }
        })
        .error(redrawPromise.rejector());
      template
        .render(model)
        .success(templateRenderPromise.resolver())
        .error(templateRenderPromise.rejector());
      return redrawPromise;
    },

    /**
     * Dispose old widgets and child views
     * @method disposeChildViews
     * @param  {Object} $el the $el to search for child views and widgets in
     */
    disposeChildViews: function ($el) {
      var childViewSearch,
        self = this;

      // Remove child views
      childViewSearch = $el.find(&#x27;[data-view-id]&#x27;);
      if ($el !== self.el &amp;&amp; $el.is(&#x27;[data-view-id]&#x27;)) {
        childViewSearch = childViewSearch.add($el);
      }
      childViewSearch.each(function(index, item) {
        var $item = $(item),
          childView = $item.data(&#x27;view&#x27;);
        if (childView) {
          self.childViews.remove(childView.id);
          childView.dispose();
        }
      });
    },
    /**
     * Dispose old widgets and child views
     * @method disposeWidgets
     * @param  {Object} $el the $el to search for child views and widgets in
     */
    disposeWidgets: function ($el) {
      var self = this;

      // Remove widgets
      $el.add($el.find(&#x27;[data-has-widgets]&#x27;)).each(function(index, item) {
        var $item = $(item),
          widgets = $item.data(&#x27;widgets&#x27;),
          selector, widget;
        for (selector in widgets) {
          widget = widgets[selector];
          self.widgets.remove(widget.id);
          widget.dispose();
        }
      });
      $el.removeData(&#x27;widgets&#x27;);
    },
    /**
     * Unbinds events from the model
     * @method clearModelEvents
     *
     */
    clearModelEvents: function() {
      var type,
        callback,
        dotIndex;
      if (this.eventMap
        &amp;&amp; this.eventMap.model
        &amp;&amp; this.model
        &amp;&amp; this.model instanceof EventDispatcher) {
        for (type in this.eventMap.model) {
          callback = this.eventMap.model[type];
          if (typeof callback === &#x27;object&#x27;) {
            callback = callback.on;
          }
          dotIndex = type.indexOf(&#x27;.&#x27;);
          if (dotIndex !== -1) {
            type = type.substr(0, dotIndex);
          }
          this.model.off(type, callback);
        }
      }
    },
    /**
     * Checks for strings in the event map to bind events to this automatically
     * @method bindMappedEvents
     */
    bindMappedEvents: function() {
      var callbacks,
        delegate,
        type;
      for (delegate in this.eventMap) {
        callbacks = this.eventMap[delegate];
        for (type in callbacks) {
          if (typeof this.eventMap[delegate][type] === &#x27;string&#x27;){
            this.eventMap[delegate][type] = this[this.eventMap[delegate][type]].bind(this);
          }
        }
      }
    },
    /**
     * Binds events to the view
     * @method applyEvents
     *
     */
    applyEvents: function() {
      var el = this.el,
        callbacks,
        callback,
        property,
        delegate,
        type,
        dotIndex,
        opts;
      for (delegate in this.eventMap) {
        callbacks = this.eventMap[delegate];
        if (delegate === &#x27;self&#x27;) {
          delegate = null;
        }
        for (type in callbacks) {
          callback = callbacks[type];
          property = _UNDEFINED;
          if (typeof callback === &#x27;object&#x27;) {
            opts = callback;
            callback = callback.on;
          } else {
            opts = undefined;
          }
          if (typeof callback === &#x27;string&#x27;) {
            if (callback in this) {
              callback = this[callback].bind(this);
            }
          }
          if (delegate === &#x27;model&#x27;) {
            if (this.model &amp;&amp; this.model instanceof Model) {
              dotIndex = type.indexOf(&#x27;.&#x27;);
              if (dotIndex !== -1) {
                property = type.substr(dotIndex+1);
                type = type.substr(0, dotIndex);
              }
              this.model.on(type, property, callback);
            }
          } else if (type === &#x27;animationEnd&#x27; &amp;&amp; el.animationEnd) {
            el.animationEnd(delegate, callback);
          } else if (type === &#x27;transitionEnd&#x27; &amp;&amp; el.transitionEnd) {
            el.transitionEnd(delegate, callback);
          } else {
            if (el.hammer) {
              el.hammer().on(type, delegate, callback);
            } else {
              el.on(type, delegate, callback);
            }
          }
        }
      }
    },
    /**
     * Maps multiple delegated events for the view
     * @method mapEvent
     *
     * @param {Object} map  A hash of the delegates, event types, and handlers
     *     that will be bound when the view is rendered. The map should be in
     *     the form &lt;code&gt;{delegate: {eventType: callback}}&lt;/code&gt;. For example,
     *     &lt;code&gt;{&#x27;.button&#x27;: {click: onClickButton}}&lt;/code&gt;. The events defined in
     *     [[Lavaca.fx.Animation]] and [[Lavaca.fx.Transition]] are also supported.
     *     To map an event to the view&#x27;s el, use &#x27;self&#x27; as the delegate. To map
     *     events to the view&#x27;s model, use &#x27;model&#x27; as the delegate. To limit events
     *     to only a particular property on the model, use a period-seperated
     *     syntax such as &lt;code&gt;{model: {&#x27;change.myproperty&#x27;: myCallback}}&lt;/code&gt;
     * @return {lavaca.mvc.View}  This view (for chaining)
     */
    /**
     * Maps an event for the view
     * @method mapEvent
     * @param {String} delegate  The element to which to delegate the event
     * @param {String} type  The type of event
     * @param {Function} callback  The event handler
     * @return {lavaca.mvc.View}  This view (for chaining)
     */
    mapEvent: function(delegate, type, callback) {
      var o;
      if (typeof delegate === &#x27;object&#x27;) {
        o = delegate;
        for (delegate in o) {
          for (type in o[delegate]) {
            this.mapEvent(delegate, type, o[delegate][type]);
          }
        }
      } else {
        o = this.eventMap[delegate];
        if (!o) {
          o = this.eventMap[delegate] = {};
        }
        o[type] = callback;
      }
      return this;
    },
    /**
     * Initializes widgets on the view
     * @method createWidgets
     *
     */
    createWidgets: function() {
      var cache = this.widgets,
        n,
        o,
        TWidget,
        makeWidget,
        args;
      for (n in this.widgetMap) {
        o = this.widgetMap[n];
        if (typeof o === &#x27;object&#x27;) {
          TWidget = o.TWidget;
          args = o.args
            ? ArrayUtils.isArray(o.args) ? o.args : [o.args]
            : null;
        } else {
          TWidget = o;
          args = null;
        }
        if (args) {
          makeWidget = function(el) {
            var factoryFunction = TWidget.bind.apply(TWidget, [null, el].concat(args));
            return new factoryFunction();
          };
        } else {
          makeWidget = function(el) {
            return new TWidget(el);
          };
        }
        (n === &#x27;self&#x27; ? this.el : this.el.find(n))
          .each(function(index, item) {
            var $el = $(item),
              widgetMap = $el.data(&#x27;widgets&#x27;) || {},
              widget;
            if (!widgetMap[n]) {
              widget = makeWidget($(item));
              widgetMap[n] = widget;
              cache.set(widget.id, widget);
              $el.data(&#x27;widgets&#x27;, widgetMap);
              $el.attr(&#x27;data-has-widgets&#x27;,&#x27;&#x27;);
            }
          });
      }
    },
    /**
     * Assigns multiple widget types to elements on the view
     * @method mapWidget
     * @param {Object} map  A hash of selectors to bind widgets to when the view is rendered.
     *     The map should be in the form {selector: [[Lavaca.ui.Widget]]} or
     *     {selector: {TWidget: [[Lavaca.ui.Widget]], args: [optional arguments to pass to widget constructor]}}.
     *     For example, {&#x27;form&#x27;: Lavaca.ui.Form} or {&#x27;form&#x27;: {TWidget: Lavaca.ui.Form, args: [...]}}
     * @return {Lavaca.mvc.View}  This view (for chaining)
     *
     */
    /**
     * Assigns a widget type to be created for elements matching a selector when the view is rendered
     * @method mapWidget
     * @param {String} selector  The selector for the root element of the widget
     * @param {Function} TWidget  The [[Lavaca.ui.Widget]]-derived type of widget to create
     * @return {Lavaca.mvc.View}  This view (for chaining)
     */
    /**
     * Assigns a widget type to be created for elements matching a selector when the view is rendered, and
     * accepts optional arguments to pass to the widget constructor
     * @method mapWidget
     * @param {String} selector  The selector for the root element of the widget
     * @param {Object} widgetOptions  An object with a &#x27;TWidget&#x27; key and an optional &#x27;args&#x27; key which can be
     *     an array of arguments to pass to the widget&#x27;s constructor
     * @return {Lavaca.mvc.View}  This view (for chaining)
     */
    mapWidget: function(selector, TWidget) {
      if (typeof selector === &#x27;object&#x27;) {
        var widgetTypes = selector;
        for (selector in widgetTypes) {
          this.mapWidget(selector, widgetTypes[selector]);
        }
      } else {
        this.widgetMap[selector] = TWidget;
      }
      return this;
    },
    /**
     * Initializes child views on the view, called from onRenderSuccess
     * @method createChildViews
     *
     */
    createChildViews: function() {
      var cache = this.childViews,
        n,
        self = this,
        o;
      for (n in this.childViewMap) {
        o = this.childViewMap[n];
        this.el.find(n)
          .each(function(index, item) {
            var $el = $(item),
                childView,
                model;
            if (!$el.data(&#x27;view&#x27;)) {
              if (typeof o.model === &#x27;function&#x27;) {
                model = o.model.call(self, index, item);
              } else {
                model = o.model || self.model;
              }
              childView = new o.TView($el, model, self);
              cache.set(childView.id, childView);
              if (childView.autoRender) {
                childView.render();
              }
            }
          });
      }
    },
    /*
     * Assigns a View type to be created for elements matching a selector when the view is rendered
     * @method mapChildView
     * @param {String} selector  The selector for the root element of the View
     * @param {Function} TView  The [[Lavaca.mvc.View]]-derived type of view to create
     * @param {Lavaca.mvc.Model} model  The model instance to use for the child view(s)
     * @return {Lavaca.mvc.View}  This view (for chaining)
    */
    /*
     * Assigns a View type to be created for elements matching a selector when the view is rendered
     * @method mapChildView
     * @param {String} selector  The selector for the root element of the View
     * @param {Function} TView  The [[Lavaca.mvc.View]]-derived type of view to create
     * @param {Function} model  A function which will be called once for every matching element and should return a [[Lavaca.mvc.Model]]-derived model instance
     *     to use for the child view. The function has the signature function(index, el)
     * @return {Lavaca.mvc.View}  This view (for chaining)
     */
    /**
     * Assigns multiple Views to elements on the view
     * @method mapChildView
     * @param {Object} map  A hash of selectors to view types and models to be bound when the view is rendered.
     *     The map should be in the form {selector: {TView : TView, model : lavaca.mvc.Model}}. For example, {&#x27;form&#x27;: {TView : ExampleView, model : new Model()}}
     * @return {lavaca.mvc.View}  This view (for chaining)
     *
    */
    mapChildView: function(selector, TView, model) {
      if (typeof selector === &#x27;object&#x27;) {
        var childViewTypes = selector;
        for (selector in childViewTypes) {
          this.mapChildView(selector, childViewTypes[selector].TView, childViewTypes[selector].model);
        }
      } else {
        this.childViewMap[selector] = { TView: TView, model: model };
      }
      return this;
    },

    /**
     * Listen for events triggered from child views.
     * @method mapChildViewEvent
     *
     * @param {String} type The type of event to listen for
     * @param {Function} callback The method to execute when this event type has occured
     * @param {Lavaca.mvc.View} TView (Optional) Only listen on child views of this type
     */
    /**
     * Maps multiple child event types
     * @method mapChildViewEvent
     *
     * @param {Object} map A hash of event types with callbacks and TView&#x27;s associated with that type
     *  The map should be in the form {type : {callback : {Function}, TView : TView}}
     */
    mapChildViewEvent: function(type, callback, TView) {
      if (typeof type === &#x27;object&#x27;){
        var eventTypes = type;
        for (type in eventTypes){
          //add in view type to limit events created
          this.mapChildViewEvent(type, eventTypes[type].callback, eventTypes[type].TView);
        }
      } else {
        this.childViewEventMap[type] = {
          TView: TView,
          callback: callback
        };
      }
    },

    /**
     * Called from onRenderSuccess of the view, adds listeners to all childviews if present
     * @method applyChildViewEvent
     *
     */
    applyChildViewEvents: function() {
      var childViewEventMap = this.childViewEventMap,
        type;
      for (type in childViewEventMap) {
        this.childViews.each(function(key, item) {
          var callbacks,
            callback,
            i = -1;

          if (!childViewEventMap[type].TView || item instanceof childViewEventMap[type].TView) {
            callbacks = item.callbacks[type] || [];
            while (!!(callback = callbacks[++i])) {
              if (callback === childViewEventMap[type].callback) {
                return;
              }
            }
            item.on(type, childViewEventMap[type].callback);
          }
        });
      }
    },
    /**
     * Executes when the template renders successfully
     * @method onRenderSuccess
     *
     * @param {Event} e  The render event. This object should have a string property named &quot;html&quot;
     *   that contains the template&#x27;s rendered HTML output.
     */
    onRenderSuccess: function(e) {
      this.el.html(e.html);
      this.bindMappedEvents();
      this.applyEvents();
      this.createWidgets();
      this.createChildViews();
      this.applyChildViewEvents();
      this.el.data(&#x27;view&#x27;, this);
      this.el.attr(&#x27;data-view-id&#x27;, this.id);
      this.hasRendered = true;
    },
    /**
     * Executes when the template fails to render
     * @method onRenderError
     *
     * @param {Event} e  The error event. This object should have a string property named &quot;err&quot;
     *   that contains the error message.
     */
    onRenderError: function(e) {
      console.log(e.err);
    },
    /**
     * Readies the view for garbage collection
     * @method dispose
     */
    dispose: function() {
      if (this.model) {
        this.clearModelEvents();
      }
      if (this.childViews.count()) {
        this.disposeChildViews(this.el);
      }
      if (this.widgets.count()) {
        this.disposeWidgets(this.el);
      }

      // Do not dispose of template or model
      this.template
        = this.model
        = this.parentView
        = null;

      EventDispatcher.prototype.dispose.apply(this, arguments);
    },

    // -------------- PageView methods --------------------

    /**
     * Creates the view&#x27;s wrapper element
     * @method wrapper
     * @return {jQuery}  The wrapper element
     */
    wrapper: function() {
      return $(&#x27;&lt;div class=&quot;view&quot;&gt;&lt;/div&gt;&#x27;);
    },
    /**
     * Creates the view&#x27;s interior content wrapper element
     * @method interior
     * @return {jQuery} The interior content wrapper element
     */
    interior: function() {
      return $(&#x27;&lt;div class=&quot;view-interior&quot;&gt;&lt;/div&gt;&#x27;);
    },


    /**
     * Adds this view to a container
     * @method insertInto
     * @param {jQuery} container  The containing element
     */
    insertInto: function(container) {
      if (this.shell.parent()[0] !== container[0]) {
        var layers = container.children(&#x27;[data-layer-index]&#x27;),
          i = -1,
          layer;
        while (!!(layer = layers[++i])) {
          layer = $(layer);
          if (layer.attr(&#x27;data-layer-index&#x27;) &gt; this.index) {
            this.shell.insertBefore(layer);
            return;
          }
        }
        container.append(this.shell);
      }
    },

    /**
     * Executes when the user navigates to this view
     * @method enter
     * @param {jQuery} container  The parent element of all views
     * @param {Array} exitingViews  The views that are exiting as this one enters
     * @return {lavaca.util.Promise}  A promise
     */
    enter: function(container) {
      var promise = new Promise(this),
        renderPromise;
      container = $(container);
      if (!this.hasRendered) {
        renderPromise = this
          .render()
          .error(promise.rejector());
      }
      this.insertInto(container);
      if (renderPromise) {
        promise.when(renderPromise);
      } else {
        setTimeout(promise.resolver().bind(this),0);
      }
      promise.then(function() {
        /**
         * Fired when there was an error during rendering process
         * @event rendererror
         */
        this.trigger(&#x27;enter&#x27;);
      });
      return promise;
    },
    /**
     * Executes when the user navigates away from this view
     * @method exit
     *
     * @param {jQuery} container  The parent element of all views
     * @param {Array} enteringViews  The views that are entering as this one exits
     * @return {lavaca.util.Promise}  A promise
     */
    exit: function() {
      var promise = new Promise(this);
      this.shell.detach();
      setTimeout(promise.resolver(),0);
      promise.then(function() {
        /**
         * Fired when there was an error during rendering process
         * @event rendererror
         */
        this.trigger(&#x27;exit&#x27;);
      });
      return promise;
    }
  });

  return View;

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
