<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/components/dustjs-linkedin-helpers/dist/dust-helpers-1.1.1.js - lavaca</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="lavaca"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/lavaca.env.Device.html">lavaca.env.Device</a></li>
            
                <li><a href="../classes/lavaca.events.EventDispatcher.html">lavaca.events.EventDispatcher</a></li>
            
                <li><a href="../classes/lavaca.fx.Animation.html">lavaca.fx.Animation</a></li>
            
                <li><a href="../classes/lavaca.fx.Spring.html">lavaca.fx.Spring</a></li>
            
                <li><a href="../classes/lavaca.fx.Transform.html">lavaca.fx.Transform</a></li>
            
                <li><a href="../classes/lavaca.fx.Transition.html">lavaca.fx.Transition</a></li>
            
                <li><a href="../classes/lavaca.mvc.Application.html">lavaca.mvc.Application</a></li>
            
                <li><a href="../classes/lavaca.mvc.AttributeEvent.html">lavaca.mvc.AttributeEvent</a></li>
            
                <li><a href="../classes/lavaca.mvc.Collection.html">lavaca.mvc.Collection</a></li>
            
                <li><a href="../classes/lavaca.mvc.Controller.html">lavaca.mvc.Controller</a></li>
            
                <li><a href="../classes/lavaca.mvc.ItemEvent.html">lavaca.mvc.ItemEvent</a></li>
            
                <li><a href="../classes/lavaca.mvc.Model.html">lavaca.mvc.Model</a></li>
            
                <li><a href="../classes/lavaca.mvc.Route.html">lavaca.mvc.Route</a></li>
            
                <li><a href="../classes/lavaca.mvc.Router.html">lavaca.mvc.Router</a></li>
            
                <li><a href="../classes/lavaca.mvc.View.html">lavaca.mvc.View</a></li>
            
                <li><a href="../classes/lavaca.mvc.ViewManager.html">lavaca.mvc.ViewManager</a></li>
            
                <li><a href="../classes/lavaca.net.Connectivity.html">lavaca.net.Connectivity</a></li>
            
                <li><a href="../classes/lavaca.net.History.html">lavaca.net.History</a></li>
            
                <li><a href="../classes/lavaca.storage.LocalStore.html">lavaca.storage.LocalStore</a></li>
            
                <li><a href="../classes/lavaca.storage.Store.html">lavaca.storage.Store</a></li>
            
                <li><a href="../classes/lavaca.ui.DustTemplate.html">lavaca.ui.DustTemplate</a></li>
            
                <li><a href="../classes/lavaca.ui.Form.html">lavaca.ui.Form</a></li>
            
                <li><a href="../classes/lavaca.ui.LoadingIndicator.html">lavaca.ui.LoadingIndicator</a></li>
            
                <li><a href="../classes/lavaca.ui.Template.html">lavaca.ui.Template</a></li>
            
                <li><a href="../classes/lavaca.ui.Widget.html">lavaca.ui.Widget</a></li>
            
                <li><a href="../classes/lavaca.util.ArrayUtils.html">lavaca.util.ArrayUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Cache.html">lavaca.util.Cache</a></li>
            
                <li><a href="../classes/lavaca.util.Config.html">lavaca.util.Config</a></li>
            
                <li><a href="../classes/lavaca.util.DateUtils.html">lavaca.util.DateUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Disposable.html">lavaca.util.Disposable</a></li>
            
                <li><a href="../classes/lavaca.util.extend.html">lavaca.util.extend</a></li>
            
                <li><a href="../classes/lavaca.util.Map.html">lavaca.util.Map</a></li>
            
                <li><a href="../classes/lavaca.util.Promise.html">lavaca.util.Promise</a></li>
            
                <li><a href="../classes/lavaca.util.resolve.html">lavaca.util.resolve</a></li>
            
                <li><a href="../classes/lavaca.util.StringUtils.html">lavaca.util.StringUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Translation.html">lavaca.util.Translation</a></li>
            
                <li><a href="../classes/lavaca.util.uuid.html">lavaca.util.uuid</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/components/dustjs-linkedin-helpers/dist/dust-helpers-1.1.1.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//
// Dust-helpers - Additional functionality for dustjs-linkedin package v1.1.1
//
// Copyright (c) 2012, LinkedIn
// Released under the MIT License.
//

(function(dust){

// Note: all error conditions are logged to console and failed silently

/* make a safe version of console if it is not available
 * currently supporting:
 *   _console.log
 * */
var _console = (typeof console !== &#x27;undefined&#x27;)? console: {
  log: function(){
     /* a noop*/
   }
};

function isSelect(context) {
  var value = context.current();
  return typeof value === &quot;object&quot; &amp;&amp; value.isSelect === true;
}

// Utility method : toString() equivalent for functions
function jsonFilter(key, value) {
  if (typeof value === &quot;function&quot;) {
    return value.toString();
  }
  return value;
}

// Utility method: to invoke the given filter operation such as eq/gt etc
function filter(chunk, context, bodies, params, filterOp) {
  params = params || {};
  var body = bodies.block,
      actualKey,
      expectedValue,
      filterOpType = params.filterOpType || &#x27;&#x27;;
  // when @eq, @lt etc are used as standalone helpers, key is required and hence check for defined
  if ( typeof params.key !== &quot;undefined&quot;) {
    actualKey = dust.helpers.tap(params.key, chunk, context);
  }
  else if (isSelect(context)) {
    actualKey = context.current().selectKey;
    //  supports only one of the blocks in the select to be selected
    if (context.current().isResolved) {
      filterOp = function() { return false; };
    }
  }
  else {
    _console.log (&quot;No key specified for filter in:&quot; + filterOpType + &quot; helper &quot;);
    return chunk;
  }
  expectedValue = dust.helpers.tap(params.value, chunk, context);
  // coerce both the actualKey and expectedValue to the same type for equality and non-equality compares
  if (filterOp(coerce(expectedValue, params.type, context), coerce(actualKey, params.type, context))) {
    if (isSelect(context)) {
      context.current().isResolved = true;
    }
    // we want helpers without bodies to fail gracefully so check it first
    if(body) {
     return chunk.render(body, context);
    }
    else {
      _console.log( &quot;Missing body block in the &quot; + filterOpType + &quot; helper &quot;);
      return chunk;
    }
   }
   else if (bodies[&#x27;else&#x27;]) {
    return chunk.render(bodies[&#x27;else&#x27;], context);
  }
  return chunk;
}

function coerce (value, type, context) {
  if (value) {
    switch (type || typeof(value)) {
      case &#x27;number&#x27;: return +value;
      case &#x27;string&#x27;: return String(value);
      case &#x27;boolean&#x27;: {
        value = (value === &#x27;false&#x27; ? false : value);
        return Boolean(value);
      }
      case &#x27;date&#x27;: return new Date(value);
      case &#x27;context&#x27;: return context.get(value);
    }
  }

  return value;
}

var helpers = {

  // Utility helping to resolve dust references in the given chunk
  // uses the Chunk.render method to resolve value
  /*
   Reference resolution rules:
   if value exists in JSON:
    &quot;&quot; or &#x27;&#x27; will evaluate to false, boolean false, null, or undefined will evaluate to false,
    numeric 0 evaluates to true, so does, string &quot;0&quot;, string &quot;null&quot;, string &quot;undefined&quot; and string &quot;false&quot;. 
    Also note that empty array -&gt; [] is evaluated to false and empty object -&gt; {} and non-empty object are evaluated to true
    The type of the return value is string ( since we concatenate to support interpolated references 

   if value does not exist in JSON and the input is a single reference: {x}
     dust render emits empty string, and we then return false   
     
   if values does not exist in JSON and the input is interpolated references : {x} &lt; {y}
     dust render emits &lt;  and we return the partial output 
     
  */
  &quot;tap&quot;: function( input, chunk, context ){
    // return given input if there is no dust reference to resolve
    var output = input;
    // dust compiles a string/reference such as {foo} to function, 
    if( typeof input === &quot;function&quot;){
      // just a plain function (a.k.a anonymous functions) in the context, not a dust &#x60;body&#x60; function created by the dust compiler
      if( input.isFunction === true ){
        output = input();
      } else {
        output = &#x27;&#x27;;
        chunk.tap(function(data){
           output += data;
           return &#x27;&#x27;;
          }).render(input, context).untap();
        if( output === &#x27;&#x27; ){
          output = false;
        }
      }
    }
   return output;
  },

  &quot;sep&quot;: function(chunk, context, bodies) {
    var body = bodies.block;
    if (context.stack.index === context.stack.of - 1) {
      return chunk;
    }
    if(body) {
     return bodies.block(chunk, context);
    }
    else {
     return chunk;
    }
  },

  &quot;idx&quot;: function(chunk, context, bodies) {
    var body = bodies.block;
     if(body) {
       return bodies.block(chunk, context.push(context.stack.index));
     }
     else {
       return chunk;
     }
  },

  /**
   * contextDump helper
   * @param key specifies how much to dump.
   * &quot;current&quot; dumps current context. &quot;full&quot; dumps the full context stack.
   * @param to specifies where to write dump output.
   * Values can be &quot;console&quot; or &quot;output&quot;. Default is output.
   */
  &quot;contextDump&quot;: function(chunk, context, bodies, params) {
    var p = params || {},
      to = p.to || &#x27;output&#x27;,
      key = p.key || &#x27;current&#x27;,
      dump;
    to = dust.helpers.tap(to, chunk, context),
    key = dust.helpers.tap(key, chunk, context);
    if (key === &#x27;full&#x27;) {
      dump = JSON.stringify(context.stack, jsonFilter, 2);
    }
    else {
      dump = JSON.stringify(context.stack.head, jsonFilter, 2);
    }
    if (to === &#x27;console&#x27;) {
      _console.log(dump);
      return chunk;
    }
    else {
      return chunk.write(dump);
    }
  },
  /**
   if helper for complex evaluation complex logic expressions.
   Note : #1 if helper fails gracefully when there is no body block nor else block
          #2 Undefined values and false values in the JSON need to be handled specially with .length check
             for e.g @if cond=&quot; &#x27;{a}&#x27;.length &amp;&amp; &#x27;{b}&#x27;.length&quot; is advised when there are chances of the a and b been
             undefined or false in the context
          #3 Use only when the default ? and ^ dust operators and the select fall short in addressing the given logic,
             since eval executes in the global scope
          #4 All dust references are default escaped as they are resolved, hence eval will block malicious scripts in the context
             Be mindful of evaluating a expression that is passed through the unescape filter -&gt; |s
   @param cond, either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. cond=&quot;2&gt;3&quot;
                a dust reference is also enclosed in double quotes, e.g. cond=&quot;&#x27;{val}&#x27;&#x27; &gt; 3&quot;
    cond argument should evaluate to a valid javascript expression
   **/

  &quot;if&quot;: function( chunk, context, bodies, params ){
    var body = bodies.block,
        skip = bodies[&#x27;else&#x27;];
    if( params &amp;&amp; params.cond){
      var cond = params.cond;
      cond = dust.helpers.tap(cond, chunk, context);
      // eval expressions with given dust references
      if(eval(cond)){
       if(body) {
        return chunk.render( bodies.block, context );
       }
       else {
         _console.log( &quot;Missing body block in the if helper!&quot; );
         return chunk;
       }
      }
      if(skip){
       return chunk.render( bodies[&#x27;else&#x27;], context );
      }
    }
    // no condition
    else {
      _console.log( &quot;No condition given in the if helper!&quot; );
    }
    return chunk;
  },

  /**
   * math helper
   * @param key is the value to perform math against
   * @param method is the math method,  is a valid string supported by math helper like mod, add, subtract
   * @param operand is the second value needed for operations like mod, add, subtract, etc.
   * @param round is a flag to assure that an integer is returned
   */
  &quot;math&quot;: function ( chunk, context, bodies, params ) {
    //key and method are required for further processing
    if( params &amp;&amp; typeof params.key !== &quot;undefined&quot; &amp;&amp; params.method ){
      var key  = params.key,
          method = params.method,
          // operand can be null for &quot;abs&quot;, ceil and floor
          operand = params.operand,
          round = params.round,
          mathOut = null,
          operError = function(){_console.log(&quot;operand is required for this math method&quot;); return null;};
      key  = dust.helpers.tap(key, chunk, context);
      operand = dust.helpers.tap(operand, chunk, context);
      //  TODO: handle  and tests for negatives and floats in all math operations
      switch(method) {
        case &quot;mod&quot;:
          if(operand === 0 || operand === -0) {
            _console.log(&quot;operand for divide operation is 0/-0: expect Nan!&quot;);
          }
          mathOut = parseFloat(key) %  parseFloat(operand);
          break;
        case &quot;add&quot;:
          mathOut = parseFloat(key) + parseFloat(operand);
          break;
        case &quot;subtract&quot;:
          mathOut = parseFloat(key) - parseFloat(operand);
          break;
        case &quot;multiply&quot;:
          mathOut = parseFloat(key) * parseFloat(operand);
          break;
        case &quot;divide&quot;:
         if(operand === 0 || operand === -0) {
           _console.log(&quot;operand for divide operation is 0/-0: expect Nan/Infinity!&quot;);
         }
          mathOut = parseFloat(key) / parseFloat(operand);
          break;
        case &quot;ceil&quot;:
          mathOut = Math.ceil(parseFloat(key));
          break;
        case &quot;floor&quot;:
          mathOut = Math.floor(parseFloat(key));
          break;
        case &quot;round&quot;:
          mathOut = Math.round(parseFloat(key));
          break;
        case &quot;abs&quot;:
          mathOut = Math.abs(parseFloat(key));
          break;
        default:
          _console.log( &quot;method passed is not supported&quot; );
     }

      if (mathOut !== null){
        if (round) {
          mathOut = Math.round(mathOut);
        }
        if (bodies &amp;&amp; bodies.block) {
          // with bodies act like the select helper with mathOut as the key
          // like the select helper bodies[&#x27;else&#x27;] is meaningless and is ignored
          return chunk.render(bodies.block, context.push({ isSelect: true, isResolved: false, selectKey: mathOut }));
        } else {
          // self closing math helper will return the calculated output
          return chunk.write(mathOut);
        }
       } else {
        return chunk;
      }
    }
    // no key parameter and no method
    else {
      _console.log( &quot;Key is a required parameter for math helper along with method/operand!&quot; );
    }
    return chunk;
  },
   /**
   select helperworks with one of the eq/gt/gte/lt/lte/default providing the functionality
   of branching conditions
   @param key,  ( required ) either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   **/
  &quot;select&quot;: function(chunk, context, bodies, params) {
    var body = bodies.block;
    // key is required for processing, hence check for defined
    if( params &amp;&amp; typeof params.key !== &quot;undefined&quot;){
      // returns given input as output, if the input is not a dust reference, else does a context lookup
      var key = dust.helpers.tap(params.key, chunk, context);
      // bodies[&#x27;else&#x27;] is meaningless and is ignored
      if( body ) {
       return chunk.render(bodies.block, context.push({ isSelect: true, isResolved: false, selectKey: key }));
      }
      else {
       _console.log( &quot;Missing body block in the select helper &quot;);
       return chunk;
      }
    }
    // no key
    else {
      _console.log( &quot;No key given in the select helper!&quot; );
    }
    return chunk;
  },

  /**
   eq helper compares the given key is same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type=&quot;number&quot; when comparing numeric
   **/
  &quot;eq&quot;: function(chunk, context, bodies, params) {
    if(params) {
      params.filterOpType = &quot;eq&quot;;
    }
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual === expected; });
  },

  /**
   ne helper compares the given key is not the same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type=&quot;number&quot; when comparing numeric
   **/
  &quot;ne&quot;: function(chunk, context, bodies, params) {
    if(params) {
      params.filterOpType = &quot;ne&quot;;
      return filter(chunk, context, bodies, params, function(expected, actual) { return actual !== expected; });
    }
   return chunk;
  },

  /**
   lt helper compares the given key is less than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type=&quot;number&quot; when comparing numeric
   **/
  &quot;lt&quot;: function(chunk, context, bodies, params) {
     if(params) {
       params.filterOpType = &quot;lt&quot;;
       return filter(chunk, context, bodies, params, function(expected, actual) { return actual &lt; expected; });
     }
  },

  /**
   lte helper compares the given key is less or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type=&quot;number&quot; when comparing numeric
  **/
  &quot;lte&quot;: function(chunk, context, bodies, params) {
     if(params) {
       params.filterOpType = &quot;lte&quot;;
       return filter(chunk, context, bodies, params, function(expected, actual) { return actual &lt;= expected; });
     }
    return chunk;
  },


  /**
   gt helper compares the given key is greater than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type=&quot;number&quot; when comparing numeric
   **/
  &quot;gt&quot;: function(chunk, context, bodies, params) {
    // if no params do no go further
    if(params) {
      params.filterOpType = &quot;gt&quot;;
      return filter(chunk, context, bodies, params, function(expected, actual) { return actual &gt; expected; });
    }
    return chunk;
  },

 /**
   gte helper, compares the given key is greater than or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key=&quot;foo&quot;
                a dust reference may or may not be enclosed in double quotes, e.g. key=&quot;{val}&quot; and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type=&quot;number&quot; when comparing numeric
  **/
  &quot;gte&quot;: function(chunk, context, bodies, params) {
     if(params) {
      params.filterOpType = &quot;gte&quot;;
      return filter(chunk, context, bodies, params, function(expected, actual) { return actual &gt;= expected; });
     }
    return chunk; 
  },

  // to be used in conjunction with the select helper
  // TODO: fix the helper to do nothing when used standalone
  &quot;default&quot;: function(chunk, context, bodies, params) {
    // does not require any params
     if(params) {
        params.filterOpType = &quot;default&quot;;
      }
     return filter(chunk, context, bodies, params, function(expected, actual) { return true; });
  },

  /**
  * size helper prints the size of the given key
  * Note : size helper is self closing and does not support bodies
  * @param key, the element whose size is returned
  */
  &quot;size&quot;: function( chunk, context, bodies, params ) {
    var key, value=0, nr, k;
    params = params || {};
    key = params.key;
    if (!key || key === true) { //undefined, null, &quot;&quot;, 0
      value = 0;
    }
    else if(dust.isArray(key)) { //array
      value = key.length;
    }
    else if (!isNaN(parseFloat(key)) &amp;&amp; isFinite(key)) { //numeric values
      value = key;
    }
    else if (typeof key  === &quot;object&quot;) { //object test
      //objects, null and array all have typeof ojbect...
      //null and array are already tested so typeof is sufficient http://jsperf.com/isobject-tests
      nr = 0;
      for(k in key){
        if(Object.hasOwnProperty.call(key,k)){
          nr++;
        }
      }
      value = nr;
    } else {
      value = (key + &#x27;&#x27;).length; //any other value (strings etc.)
    }
    return chunk.write(value);
  }
  
  
};

dust.helpers = helpers;

})(typeof exports !== &#x27;undefined&#x27; ? module.exports = require(&#x27;dustjs-linkedin&#x27;) : dust);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
